import { MainMenuConfig, ProjectAsset, MSX1ColorValue } from '../../types';
import { MSX1_PALETTE_MAP } from '../../constants';
import { MAIN_MENU_ASM_LOGIC } from './mainMenuAsmLogic';

// Helper to sanitize names for ASM labels
const toAsmLabel = (name: string, prefix: string = ''): string => {
    return (prefix + name)
        .replace(/[^a-zA-Z0-9_]/g, '_')
        .toUpperCase();
}

// A simple mapping for common keys to example scancodes/ASCII
const keyToAsmValue = (key: string): { value: number; comment: string } => {
    if (key.length === 1) {
        const charCode = key.charCodeAt(0);
        if (charCode >= 32 && charCode <= 126) {
            return { value: charCode, comment: `ASCII for '${key}'` };
        }
    }
    // For special keys, use placeholder values and comments.
    // The game engine would need to map these to actual scancodes.
    switch (key.toLowerCase()) {
        case 'arrowup': return { value: 28, comment: `Example Scancode for ArrowUp` };
        case 'arrowdown': return { value: 29, comment: `Example Scancode for ArrowDown` };
        case 'arrowleft': return { value: 30, comment: `Example Scancode for ArrowLeft` };
        case 'arrowright': return { value: 31, comment: `Example Scancode for ArrowRight` };
        case ' ': return { value: 32, comment: `ASCII for Space` };
        default: return { value: 0, comment: `Custom key '${key}' - define value` };
    }
};

export const generateMainMenuASM = (config: MainMenuConfig, allAssets: ProjectAsset[]): string => {
    let asm = `;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Main Menu Configuration Data
;; Generated by MSX Retro Game IDE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

MENU_IS_ENABLED       EQU ${config.isEnabled ? 1 : 0}
MENU_OPTIONS_COUNT    EQU ${config.options.filter(o => o.enabled).length}
MENU_DEFAULT_VOLUME   EQU ${config.settings.volume}

; --- Key Mappings (Example Scancodes/ASCII) ---
`;
    const keyUp = keyToAsmValue(config.keyMapping.up);
    const keyDown = keyToAsmValue(config.keyMapping.down);
    const keyLeft = keyToAsmValue(config.keyMapping.left);
    const keyRight = keyToAsmValue(config.keyMapping.right);
    const keyFire1 = keyToAsmValue(config.keyMapping.fire1);
    const keyFire2 = keyToAsmValue(config.keyMapping.fire2);

    asm += `MENU_KEY_UP           EQU ${keyUp.value} ; ${keyUp.comment}\n`;
    asm += `MENU_KEY_DOWN         EQU ${keyDown.value} ; ${keyDown.comment}\n`;
    asm += `MENU_KEY_LEFT         EQU ${keyLeft.value} ; ${keyLeft.comment}\n`;
    asm += `MENU_KEY_RIGHT        EQU ${keyRight.value} ; ${keyRight.comment}\n`;
    asm += `MENU_KEY_FIRE1        EQU ${keyFire1.value} ; ${keyFire1.comment}\n`;
    asm += `MENU_KEY_FIRE2        EQU ${keyFire2.value} ; ${keyFire2.comment}\n\n`;

    asm += `;; --- Visual Assets --- \n`;
    const menuScreenAsset = allAssets.find(a => a.id === config.menuScreenAssetId);
    const menuScreenLabel = menuScreenAsset ? toAsmLabel(menuScreenAsset.name, 'ASSET_') : '0';
    asm += `MENU_BG_SCREEN_ASSET_PTR: DW ${menuScreenLabel} ; Pointer to background screenmap asset data, or 0 if none\n`;

    const cursorSpriteAsset = allAssets.find(a => a.id === config.cursorSpriteAssetId);
    const cursorSpriteLabel = cursorSpriteAsset ? toAsmLabel(cursorSpriteAsset.name, 'ASSET_') : '0';
    asm += `MENU_CURSOR_SPRITE_ASSET_PTR: DW ${cursorSpriteLabel} ; Pointer to cursor sprite asset data, or 0 if none\n\n`;

    asm += `;; --- Menu Colors (MSX1 Palette Indices) ---\n`;
    const colorToIdx = (hex: MSX1ColorValue) => MSX1_PALETTE_MAP.get(hex)?.index ?? 15;
    asm += `MENU_COLOR_TEXT:              DB ${colorToIdx(config.menuColors.text)}\n`;
    asm += `MENU_COLOR_BACKGROUND:        DB ${colorToIdx(config.menuColors.background)}\n`;
    asm += `MENU_COLOR_HIGHLIGHT_TEXT:    DB ${colorToIdx(config.menuColors.highlightText)}\n`;
    asm += `MENU_COLOR_HIGHLIGHT_BG:      DB ${colorToIdx(config.menuColors.highlightBackground)}\n`;
    asm += `MENU_COLOR_BORDER:            DB ${colorToIdx(config.menuColors.border || 'transparent')}\n\n`;


    asm += `;; --- Menu Options Table --- \n`;
    asm += `;; Format: [DW label_string, DB enabled_flag]\n`;
    asm += `MENU_OPTIONS_TABLE:\n`;
    config.options.forEach((opt, index) => {
        if (!opt.enabled) return;
        asm += `    DW MENU_OPTION_${index + 1}_LABEL\n`;
    });
    asm += `\n`;

    asm += `;; --- Option Labels (null-terminated strings) ---\n`;
    config.options.forEach((opt, index) => {
        if (!opt.enabled) return;
        asm += `MENU_OPTION_${index + 1}_LABEL: DB "${opt.label}", 0\n`;
    });
    asm += `\n`;

    asm += `;; --- Continue Screen Data (null-terminated strings) ---\n`;
    asm += `MENU_CONTINUE_TITLE: DB "${config.continueScreen.title}", 0\n`;
    asm += `MENU_CONTINUE_PROMPT: DB "${config.continueScreen.prompt}", 0\n\n`;
    
    asm += `;; --- Intro Screen Data ---\n`;
    // Split multiline text into multiple DB statements
    const introLines = config.introScreen.text.split('\n');
    asm += `MENU_INTRO_TEXT:\n`;
    introLines.forEach((line, index) => {
        const isLastLine = index === introLines.length - 1;
        // Add null terminator only if it's the very last part of the text.
        // If the text ends with a newline, the last line will be empty, and we add a 0.
        // If it doesn't, the last line has content, and we add a 0 after it.
        const terminator = isLastLine ? ", 0" : ", 10" // 10 = Line Feed
        asm += `    DB "${line}"${terminator}\n`;
    });

    const introBgAsset = allAssets.find(a => a.id === config.introScreen.backgroundAssetId);
    const introBgAssetLabel = introBgAsset ? toAsmLabel(introBgAsset.name, 'ASSET_') : '0';
    asm += `MENU_INTRO_BG_ASSET_PTR: DW ${introBgAssetLabel} ; Pointer to background asset data, or 0 if none\n\n`;
    
    asm += `;; End of Main Menu Data\n`;
    
    asm += `\n\n${MAIN_MENU_ASM_LOGIC}\n`;

    return asm;
};