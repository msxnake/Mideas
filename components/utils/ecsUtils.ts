
import { EntityTemplate, ComponentDefinition, ProjectAsset } from '../../types';

// Helper to sanitize names for ASM labels
const toAsmLabel = (name: string, prefix: string = ''): string => {
    // Sanitize by replacing invalid characters, then make uppercase.
    // Removes extension like .asm from filenames.
    return (prefix + name.replace(/\.asm$/i, ''))
        .replace(/[^a-zA-Z0-9_]/g, '_')
        .toUpperCase();
}

export const generateTemplatesASM = (
    templates: EntityTemplate[], 
    components: ComponentDefinition[], 
    allAssets: ProjectAsset[]
): string => {
    let asm = `;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Entity Templates Data
;; Generated by MSX Retro Game IDE
;;
;; This file contains the definitions for all entity templates.
;; The game engine uses this data to spawn entities.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

`;

    // --- Component ID Definitions ---
    asm += `;; --- Component IDs ---\n`;
    asm += `;; These IDs must match the game engine's component parsing logic.\n`;
    const componentIdMap = new Map<string, number>();
    components.forEach((comp, index) => {
        // We use the index in the array as the runtime ID for simplicity.
        // The game engine must have the same order or a lookup table.
        componentIdMap.set(comp.id, index);
        asm += `${toAsmLabel(comp.name, 'COMP_ID_')} EQU ${index}\n`;
    });
    asm += '\n';

    // --- Template Pointers Table ---
    asm += `;; --- Entity Template Pointers Table ---\n`;
    asm += `ENTITY_TEMPLATES_TABLE:\n`;
    templates.forEach(tpl => {
        asm += `    DEFW ${toAsmLabel(tpl.name, 'TPL_')}\n`;
    });
    asm += `    DEFW 0 ; End of table\n\n`;

    // --- Individual Template Data ---
    templates.forEach(tpl => {
        asm += `;; --- Template Data: ${tpl.name} ---\n`;
        asm += `;; ID: ${tpl.id}\n`;
        asm += `${toAsmLabel(tpl.name, 'TPL_')}:\n`;
        asm += `    DB ${tpl.components.length} ; Component count\n\n`;
        
        tpl.components.forEach(tc => {
            const compDef = components.find(c => c.id === tc.definitionId);
            if (!compDef) {
                asm += `    ;; WARNING: Component definition for '${tc.definitionId}' not found. Skipping.\n\n`;
                return;
            }

            const componentId = componentIdMap.get(compDef.id);
            if (componentId === undefined) {
                 asm += `    ;; WARNING: Component ID for '${compDef.name}' could not be resolved. Skipping.\n\n`;
                 return;
            }

            asm += `    ;; Component: ${compDef.name}\n`;
            asm += `    DB ${componentId} ; ID for ${compDef.name}\n`;
            
            compDef.properties.forEach(prop => {
                const value = tc.defaultValues[prop.name] ?? prop.defaultValue;
                if (value === undefined) {
                    asm += `    ;; Property '${prop.name}' has no value, defaulting to 0.\n`
                }
                
                switch(prop.type) {
                    case 'byte':
                        asm += `    DB ${parseInt(String(value), 10) || 0} ; ${prop.name}\n`;
                        break;
                    case 'word':
                        asm += `    DW ${parseInt(String(value), 10) || 0} ; ${prop.name}\n`;
                        break;
                    case 'boolean':
                        asm += `    DB ${value === true || String(value).toLowerCase() === 'true' ? 1 : 0} ; ${prop.name}\n`;
                        break;
                    case 'string':
                        // Strings are complex. We'll output a label and assume the user defines it elsewhere.
                        const strLabel = toAsmLabel(`${tpl.name}_${compDef.name}_${prop.name}`, 'STR_');
                        asm += `    DW ${strLabel} ; ${prop.name}: "${value}" (Address of string)\n`;
                        break;
                    case 'sprite_ref':
                    case 'sound_ref':
                    case 'behavior_script_ref':
                    case 'entity_template_ref':
                         const asset = allAssets.find(a => a.id === value);
                         const assetLabel = asset ? toAsmLabel(asset.name, 'ASSET_') : '0'; // Default to 0 (NULL) if not found
                         asm += `    DW ${assetLabel} ; ${prop.name}: ref to ${asset?.name || 'NULL'}\n`;
                        break;
                    case 'color': // This one is not standard for game logic, but we can export as bytes.
                         const colorHex = String(value || '#000000').replace('#','');
                         const r = parseInt(colorHex.substring(0,2), 16) || 0;
                         const g = parseInt(colorHex.substring(2,4), 16) || 0;
                         const b = parseInt(colorHex.substring(4,6), 16) || 0;
                         asm += `    DB ${r}, ${g}, ${b} ; ${prop.name}: RGB color ${value}\n`;
                        break;
                    default:
                        // This ensures we don't forget a type if new ones are added
                        const _exhaustiveCheck: never = prop.type;
                        asm += `    ;; WARNING: Unsupported property type '${_exhaustiveCheck}' for '${prop.name}'.\n`
                }
            });
            asm += '\n';
        });
    });

    asm += `\n;; --- ASSET/STRING DEFINITIONS ---\n`;
    asm += `;; The assembler needs to know the memory addresses for the asset references used above.\n`;
    asm += `;; Define your asset labels below, for example:\n`;
    asm += `;; ASSET_PLAYER_SPRITE_DATA: INCBIN "sprites/player.bin"\n`;
    asm += `;; STR_PLAYER_ANIMATION_IDLE: DB "idle",0\n\n`;

    return asm;
};
